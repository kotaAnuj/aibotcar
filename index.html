
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Car - Precision Steering Control</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #0f0; 
            padding: 10px;
            overflow-x: hidden;
        }
        .container { max-width: 600px; margin: 0 auto; }
        .panel { 
            background: rgba(0, 255, 0, 0.05);
            border: 2px solid #0f0;
            padding: 15px; 
            margin: 10px 0; 
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        h1 { 
            text-align: center;
            color: #0ff;
            font-size: 1.8em;
            text-shadow: 0 0 10px #0ff;
            margin-bottom: 10px;
        }
        h2 { 
            color: #0f0; 
            margin-bottom: 10px; 
            font-size: 1.2em;
            border-bottom: 1px solid #0f0;
            padding-bottom: 5px;
        }
        input { 
            width: 100%; 
            padding: 12px; 
            background: #0a0a0a;
            border: 2px solid #0f0;
            color: #0f0; 
            border-radius: 5px;
            margin: 5px 0;
            font-family: monospace;
            font-size: 1em;
        }
        input:focus {
            outline: none;
            border-color: #0ff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        button { 
            width: 100%; 
            padding: 14px; 
            background: linear-gradient(135deg, #0a0 0%, #0f0 100%);
            color: #000; 
            border: none; 
            border-radius: 5px; 
            cursor: pointer;
            margin: 5px 0;
            font-size: 1em;
            font-weight: bold;
            font-family: monospace;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }
        button:hover:not(:disabled) { 
            background: linear-gradient(135deg, #0f0 0%, #0ff 100%);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 0, 0.5);
        }
        button:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }
        .stop-btn { 
            background: linear-gradient(135deg, #a00 0%, #f00 100%);
            color: #fff;
        }
        .stop-btn:hover { 
            background: linear-gradient(135deg, #f00 0%, #f80 100%);
            box-shadow: 0 5px 20px rgba(255, 0, 0, 0.5);
        }
        #videoContainer { 
            position: relative; 
            background: #000; 
            border-radius: 10px; 
            overflow: hidden;
            border: 2px solid #0f0;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        video, canvas { width: 100%; display: block; }
        canvas { position: absolute; top: 0; left: 0; }
        .metrics { 
            display: grid; 
            grid-template-columns: 1fr 1fr; 
            gap: 10px;
            margin: 10px 0;
        }
        .metric { 
            background: rgba(0, 0, 0, 0.5);
            padding: 12px; 
            text-align: center; 
            border-radius: 8px;
            border: 1px solid #0f0;
        }
        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        .metric-value { 
            font-size: 2em; 
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
        }
        .drive-val { color: #0f0; }
        .steer-val { color: #0ff; }
        .person-val { color: #ff0; }
        .fps-val { color: #f0f; }
        .log { 
            background: #000; 
            padding: 10px; 
            height: 120px; 
            overflow-y: auto; 
            font-family: monospace; 
            font-size: 0.85em;
            border-radius: 5px;
            border: 1px solid #0f0;
        }
        .log::-webkit-scrollbar { width: 8px; }
        .log::-webkit-scrollbar-track { background: #0a0a0a; }
        .log::-webkit-scrollbar-thumb { background: #0f0; border-radius: 4px; }
        .status { 
            display: inline-block; 
            width: 12px; 
            height: 12px; 
            border-radius: 50%; 
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .on { background: #0f0; box-shadow: 0 0 10px #0f0; }
        .off { background: #f00; box-shadow: 0 0 10px #f00; }
        .hidden { display: none; }
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .mode-btn {
            padding: 12px;
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #0f0;
            color: #0f0;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: bold;
        }
        .mode-btn:hover {
            background: rgba(0, 255, 0, 0.2);
            transform: scale(1.05);
        }
        .mode-btn.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #0ff;
            color: #0ff;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        .debug-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 0.85em;
            border: 1px solid #0f0;
        }
        .debug-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }
        .debug-label { color: #0ff; }
        .debug-value { color: #ff0; font-weight: bold; }
        .tuning-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .tuning-slider {
            width: 100%;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¤– AI CAR PRECISION STEERING CONTROL</h1>

        <!-- Connection Panel -->
        <div class="panel">
            <h2>ğŸ”— ESP32 CONNECTION</h2>
            <input type="text" id="esp32Ip" placeholder="Enter ESP32 IP (e.g., 192.168.1.100)">
            <button onclick="connect()">CONNECT TO CAR</button>
            <div style="margin-top: 10px;">
                <span class="status off" id="connStatus"></span>
                <span id="connText">Disconnected</span>
            </div>
        </div>

        <!-- Camera Panel -->
        <div class="panel">
            <h2>ğŸ“· CAMERA & AI VISION</h2>
            <button onclick="startCamera()">START CAMERA & AI</button>
            <div id="videoContainer" class="hidden">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="canvas"></canvas>
            </div>
            <div style="margin-top: 10px;">
                <span class="status off" id="camStatus"></span>
                <span id="camText">Camera inactive</span>
            </div>
        </div>

        <!-- Control Panel -->
        <div class="panel">
            <h2>ğŸ® CONTROL MODES</h2>
            <div class="control-grid">
                <div class="mode-btn" id="modeFollow" onclick="setMode('follow')">
                    ğŸ‘¤ FOLLOW PERSON
                </div>
                <div class="mode-btn" id="modePatrol" onclick="setMode('patrol')">
                    ğŸ”„ PATROL
                </div>
                <div class="mode-btn active" id="modeStop" onclick="setMode('stop')">
                    â¹ï¸ STOP
                </div>
                <div class="mode-btn" id="modeScan" onclick="setMode('scan')">
                    ğŸ” SCAN
                </div>
            </div>
            <button class="stop-btn" onclick="emergency()" style="margin-top: 10px;">
                ğŸš¨ EMERGENCY STOP
            </button>
        </div>

        <!-- Tuning Panel -->
        <div class="panel">
            <h2>âš™ï¸ STEERING TUNING</h2>
            <div class="tuning-controls">
                <div>
                    <label>KP (Proportional): <span id="kpValue">0.25</span></label>
                    <input type="range" min="0.01" max="1.0" step="0.01" value="0.25" 
                           class="tuning-slider" id="kpSlider" onchange="updateTuning()">
                </div>
                <div>
                    <label>KD (Derivative): <span id="kdValue">0.08</span></label>
                    <input type="range" min="0.01" max="0.5" step="0.01" value="0.08" 
                           class="tuning-slider" id="kdSlider" onchange="updateTuning()">
                </div>
                <div>
                    <label>Dead Zone: <span id="deadzoneValue">25</span>px</label>
                    <input type="range" min="5" max="100" step="5" value="25" 
                           class="tuning-slider" id="deadzoneSlider" onchange="updateTuning()">
                </div>
                <div>
                    <label>Max Steer: <span id="maxSteerValue">85</span></label>
                    <input type="range" min="30" max="100" step="5" value="85" 
                           class="tuning-slider" id="maxSteerSlider" onchange="updateTuning()">
                </div>
            </div>
            <button onclick="resetTuning()" style="margin-top: 10px;">ğŸ”„ RESET TUNING</button>
        </div>

        <!-- Status Panel -->
        <div class="panel">
            <h2>ğŸ“Š REAL-TIME TELEMETRY</h2>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">DRIVE POWER</div>
                    <div class="metric-value drive-val" id="driveVal">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">STEERING</div>
                    <div class="metric-value steer-val" id="steerVal">0</div>
                </div>
                <div class="metric">
                    <div class="metric-label">PERSON SIZE</div>
                    <div class="metric-value person-val" id="personVal">-</div>
                </div>
                <div class="metric">
                    <div class="metric-label">FPS</div>
                    <div class="metric-value fps-val" id="fpsVal">0</div>
                </div>
            </div>
        </div>

        <!-- Debug Panel -->
        <div class="panel">
            <h2>ğŸ”¬ TRACKING DEBUG</h2>
            <div class="debug-panel">
                <div class="debug-row">
                    <span class="debug-label">Person X Offset:</span>
                    <span class="debug-value" id="debugOffsetX">0 px</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Steering Error:</span>
                    <span class="debug-value" id="debugError">0 px</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">P-Term:</span>
                    <span class="debug-value" id="debugPterm">0</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">I-Term:</span>
                    <span class="debug-value" id="debugIterm">0</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">D-Term:</span>
                    <span class="debug-value" id="debugDterm">0</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Person Size:</span>
                    <span class="debug-value" id="debugSize">0 pxÂ²</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Drive Command:</span>
                    <span class="debug-value" id="debugDrive">0</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Steer Command:</span>
                    <span class="debug-value" id="debugSteer">0</span>
                </div>
                <div class="debug-row">
                    <span class="debug-label">Detection Conf:</span>
                    <span class="debug-value" id="debugConf">0%</span>
                </div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="panel">
            <h2>ğŸ“ SYSTEM LOG</h2>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GLOBAL CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let esp32Ip = '';
        let connected = false;
        let model = null;
        let mode = 'stop';
        let frameCount = 0;
        let lastFps = 0;
        let cmdCount = 0;
        let lastDetectionTime = 0;
        let filteredOffset = 0;
        let filteredSize = 35000;
let lastSteerCommand = 0;
let lastDriveCommand = 0;
let commandFilterState = { steer: 0, drive: 0 };
        
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVANCED STEERING CONTROL WITH REAL-TIME TUNING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let CONFIG = {
            // Frame geometry
            FRAME_CENTER_X: 320,
            FRAME_CENTER_Y: 240,
            
            // Control parameters - NOW TUNEABLE
            DEAD_ZONE: 25,          // Center tolerance (pixels)
            
            // PID-like gains - NOW TUNEABLE
            KP_STEER: 0.25,         // Steering proportional gain (INCREASED for responsiveness)
            KD_STEER: 0.08,         // Steering derivative gain (smoothing)
            KI_STEER: 0.02,         // Steering integral gain (new)
            
            KP_DRIVE: 0.12,         // Drive proportional gain
            
            // Target parameters
            TARGET_SIZE: 35000,     // Ideal person bounding box area
            SIZE_TOLERANCE: 10000,  // Size dead zone
            
            // Output limits - NOW TUNEABLE
            MAX_STEER: 85,          // Maximum steering command
            MIN_STEER: 20,          // Minimum steering command for movement
            MAX_DRIVE: 70,          // Maximum drive command
            MIN_DRIVE: 25,          // Minimum drive command
            STEER_SLEW_RATE: 140,   // deg/sec limit to prevent jerk
            DRIVE_SLEW_RATE: 90,    // power/sec limit
            SOFT_ZONE: 12,          // Additional easing band outside dead zone
            STEER_FILTER_ALPHA: 0.35,
            DRIVE_FILTER_ALPHA: 0.25,
            
            // Safety
            MIN_CONFIDENCE: 0.65,   // Minimum detection confidence
            COMMAND_RATE: 80,       // Command send rate (ms) - faster response
            TARGET_LOSS_TIMEOUT: 800, // ms before we consider target lost
            EMA_ALPHA: 0.35,        // smoothing factor for offset/size
            MAX_INTEGRAL: 120       // anti-windup clamp
        };
        
        let lastSteerError = 0;
        let lastCommandTime = 0;
        const pidState = {
            integral: 0,
            prevError: 0,
            prevTime: performance.now()
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        window.onload = () => {
            const saved = localStorage.getItem('esp32Ip');
            if (saved) document.getElementById('esp32Ip').value = saved;
            
            // Load saved tuning
            loadTuning();
            filteredSize = CONFIG.TARGET_SIZE;
            filteredOffset = 0;
            log('ğŸš€ System initialized - Advanced steering control ready');
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TUNING CONTROLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateTuning() {
            CONFIG.KP_STEER = parseFloat(document.getElementById('kpSlider').value);
            CONFIG.KD_STEER = parseFloat(document.getElementById('kdSlider').value);
            CONFIG.DEAD_ZONE = parseInt(document.getElementById('deadzoneSlider').value);
            CONFIG.MAX_STEER = parseInt(document.getElementById('maxSteerSlider').value);
            
            // Update display values
            document.getElementById('kpValue').textContent = CONFIG.KP_STEER.toFixed(2);
            document.getElementById('kdValue').textContent = CONFIG.KD_STEER.toFixed(2);
            document.getElementById('deadzoneValue').textContent = CONFIG.DEAD_ZONE;
            document.getElementById('maxSteerValue').textContent = CONFIG.MAX_STEER;
            
            // Save to localStorage
            saveTuning();
        }

        function resetTuning() {
            CONFIG.KP_STEER = 0.25;
            CONFIG.KD_STEER = 0.08;
            CONFIG.DEAD_ZONE = 25;
            CONFIG.MAX_STEER = 85;
            
            document.getElementById('kpSlider').value = CONFIG.KP_STEER;
            document.getElementById('kdSlider').value = CONFIG.KD_STEER;
            document.getElementById('deadzoneSlider').value = CONFIG.DEAD_ZONE;
            document.getElementById('maxSteerSlider').value = CONFIG.MAX_STEER;
            
            updateTuning();
            log('âš™ï¸ Tuning reset to defaults');
        }

        function saveTuning() {
            const tuning = {
                kp: CONFIG.KP_STEER,
                kd: CONFIG.KD_STEER,
                deadzone: CONFIG.DEAD_ZONE,
                maxSteer: CONFIG.MAX_STEER
            };
            localStorage.setItem('steeringTuning', JSON.stringify(tuning));
        }

        function loadTuning() {
            const saved = localStorage.getItem('steeringTuning');
            if (saved) {
                try {
                    const tuning = JSON.parse(saved);
                    CONFIG.KP_STEER = tuning.kp || 0.25;
                    CONFIG.KD_STEER = tuning.kd || 0.08;
                    CONFIG.DEAD_ZONE = tuning.deadzone || 25;
                    CONFIG.MAX_STEER = tuning.maxSteer || 85;
                    
                    document.getElementById('kpSlider').value = CONFIG.KP_STEER;
                    document.getElementById('kdSlider').value = CONFIG.KD_STEER;
                    document.getElementById('deadzoneSlider').value = CONFIG.DEAD_ZONE;
                    document.getElementById('maxSteerSlider').value = CONFIG.MAX_STEER;
                    updateTuning();
                } catch (e) {
                    console.log('No saved tuning found');
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONNECTION MANAGEMENT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function connect() {
            esp32Ip = document.getElementById('esp32Ip').value.trim();
            if (!esp32Ip) {
                log('âŒ Please enter ESP32 IP address');
                return;
            }
            
            localStorage.setItem('esp32Ip', esp32Ip);
            log('ğŸ”„ Connecting to ' + esp32Ip + '...');
            
            fetch(`http://${esp32Ip}/status`)
                .then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return r.json();
                })
                .then(data => {
                    connected = true;
                    updateStatus('conn', true, 'Connected âœ“');
                    log('âœ… ESP32 connected successfully');
                    log(`ğŸ“Š Status: Drive=${data.drive} Steer=${data.steer}`);
                })
                .catch(e => {
                    connected = false;
                    updateStatus('conn', false, 'Connection failed');
                    log('âŒ Connection error: ' + e.message);
                    log('ğŸ’¡ Check: 1) IP correct 2) Same WiFi 3) ESP32 powered');
                });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CAMERA & AI INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function startCamera() {
            try {
                log('ğŸ“· Requesting camera access...');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                
                video.srcObject = stream;
                document.getElementById('videoContainer').classList.remove('hidden');
                
                video.onloadedmetadata = () => {
                    video.play();
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // Update center based on actual resolution
                    CONFIG.FRAME_CENTER_X = canvas.width / 2;
                    CONFIG.FRAME_CENTER_Y = canvas.height / 2;
                    
                    updateStatus('cam', true, 'Camera active âœ“');
                    log('âœ… Camera started: ' + canvas.width + 'x' + canvas.height);
                    loadModel();
                };
                
            } catch (e) {
                log('âŒ Camera error: ' + e.message);
                updateStatus('cam', false, 'Camera error');
            }
        }

        async function loadModel() {
            try {
                log('ğŸ¤– Loading AI model (COCO-SSD)...');
                model = await cocoSsd.load();
                log('âœ… AI model loaded - Person detection ready');
                detect();
            } catch (e) {
                log('âŒ AI model error: ' + e.message);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DETECTION LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function detect() {
            if (!model) {
                requestAnimationFrame(detect);
                return;
            }
            
            try {
                const predictions = await model.detect(video);
                const people = predictions.filter(p => 
                    p.class === 'person' && p.score >= CONFIG.MIN_CONFIDENCE
                );
                
                // Update FPS counter
                frameCount++;
                const now = Date.now();
                if (now - lastFps >= 1000) {
                    document.getElementById('fpsVal').textContent = frameCount;
                    frameCount = 0;
                    lastFps = now;
                }
                
                // Draw all detections
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawDetections(predictions);
                
                // Process based on mode
                if (mode === 'follow') {
                    const target = selectTarget(people);
                    if (target) {
                        followPerson(target);
                    } else {
                        handleTargetLoss();
                    }
                } else if (mode === 'patrol') {
                    patrolMode();
                } else if (mode === 'scan') {
                    scanMode();
                } else {
                    if (mode === 'follow' && people.length === 0) {
                        handleTargetLoss();
                    }
                    throttledCommand(0, 0);
                }
                
            } catch (e) {
                console.error('Detection error:', e);
            }
            
            requestAnimationFrame(detect);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VISUALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function drawDetections(predictions) {
            predictions.forEach(p => {
                const [x, y, w, h] = p.bbox;
                const isPerson = p.class === 'person';
                
                // Bounding box
                ctx.strokeStyle = isPerson ? '#0f0' : '#ff0';
                ctx.lineWidth = isPerson ? 3 : 2;
                ctx.strokeRect(x, y, w, h);
                
                // Label with confidence
                ctx.fillStyle = isPerson ? '#0f0' : '#ff0';
                ctx.font = 'bold 14px monospace';
                const label = `${p.class} ${Math.round(p.score * 100)}%`;
                ctx.fillText(label, x, y - 8);
                
                if (isPerson) {
                    const cx = x + w / 2;
                    const cy = y + h / 2;
                    
                    // Person center point
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(cx, cy, 6, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Frame center crosshair with dead zone
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.FRAME_CENTER_X - 20, CONFIG.FRAME_CENTER_Y);
                    ctx.lineTo(CONFIG.FRAME_CENTER_X + 20, CONFIG.FRAME_CENTER_Y);
                    ctx.moveTo(CONFIG.FRAME_CENTER_X, CONFIG.FRAME_CENTER_Y - 20);
                    ctx.lineTo(CONFIG.FRAME_CENTER_X, CONFIG.FRAME_CENTER_Y + 20);
                    ctx.stroke();
                    
                    // Dead zone circle
                    ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
                    ctx.setLineDash([5, 3]);
                    ctx.beginPath();
                    ctx.arc(CONFIG.FRAME_CENTER_X, CONFIG.FRAME_CENTER_Y, CONFIG.DEAD_ZONE, 0, 2 * Math.PI);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Connection line
                    ctx.strokeStyle = 'rgba(255, 255, 0, 0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.FRAME_CENTER_X, CONFIG.FRAME_CENTER_Y);
                    ctx.lineTo(cx, cy);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Offset display
                    const offsetX = cx - CONFIG.FRAME_CENTER_X;
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px monospace';
                    ctx.fillText(`Î”x: ${Math.round(offsetX)}px`, cx + 10, cy - 10);
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ADVANCED STEERING CONTROL WITH IMPROVED ALGORITHM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function followPerson(person) {
            const now = getNow();
            const dt = Math.max((now - pidState.prevTime) / 1000, 0.001);
            pidState.prevTime = now;
            
            const [x, y, w, h] = person.bbox;
            const personCenterX = x + w / 2;
            const personSize = w * h;
            lastDetectionTime = Date.now();
            
            const rawError = personCenterX - CONFIG.FRAME_CENTER_X;
            filteredOffset = (CONFIG.EMA_ALPHA * rawError) + ((1 - CONFIG.EMA_ALPHA) * filteredOffset);
            filteredSize = (CONFIG.EMA_ALPHA * personSize) + ((1 - CONFIG.EMA_ALPHA) * filteredSize);
            const errorX = filteredOffset;
            
            let pTerm = 0;
            let iTerm = 0;
            let dTerm = 0;
            let steer = 0;
            
            if (Math.abs(errorX) > CONFIG.DEAD_ZONE) {
                pTerm = errorX * CONFIG.KP_STEER;
                
                pidState.integral += errorX * dt;
                pidState.integral = clamp(pidState.integral, -CONFIG.MAX_INTEGRAL, CONFIG.MAX_INTEGRAL);
                iTerm = pidState.integral * CONFIG.KI_STEER;
                
                const errorChange = (errorX - pidState.prevError) / dt;
                dTerm = errorChange * CONFIG.KD_STEER;
                pidState.prevError = errorX;
                
                steer = pTerm + iTerm + dTerm;
                steer = applySteeringCurve(steer, errorX);
                steer = clamp(steer, -CONFIG.MAX_STEER, CONFIG.MAX_STEER);
                
                if (Math.abs(steer) < CONFIG.MIN_STEER) {
                    steer = Math.sign(steer) * CONFIG.MIN_STEER;
                }
                
                lastSteerError = errorX;
            } else {
                pidState.integral *= 0.6;
                pidState.prevError = 0;
                lastSteerError = 0;
                steer = 0;
            }
            
            let drive = 0;
            const sizeError = CONFIG.TARGET_SIZE - filteredSize;
            if (Math.abs(sizeError) > CONFIG.SIZE_TOLERANCE * 0.6) {
                const steerPenalty = 1 - Math.min(1, Math.abs(steer) / CONFIG.MAX_STEER);
                drive = sizeError * CONFIG.KP_DRIVE * steerPenalty;
                drive = clamp(drive, -CONFIG.MAX_DRIVE, CONFIG.MAX_DRIVE);
                
                if (Math.abs(drive) < CONFIG.MIN_DRIVE) {
                    drive = Math.sign(drive) * CONFIG.MIN_DRIVE;
                }
            }
            
            steer = applySoftZoneGain(steer, errorX);
            drive *= 1 - Math.min(0.65, Math.abs(errorX) / (CONFIG.FRAME_CENTER_X)); // slow down when steering hard
            
            steer = lowPassFilter(steer, commandFilterState.steer, CONFIG.STEER_FILTER_ALPHA);
            drive = lowPassFilter(drive, commandFilterState.drive, CONFIG.DRIVE_FILTER_ALPHA);
            commandFilterState.steer = steer;
            commandFilterState.drive = drive;
            
            const steerDeltaLimit = CONFIG.STEER_SLEW_RATE * dt;
            const driveDeltaLimit = CONFIG.DRIVE_SLEW_RATE * dt;
            steer = slewLimit(steer, lastSteerCommand, steerDeltaLimit);
            drive = slewLimit(drive, lastDriveCommand, driveDeltaLimit);
            lastSteerCommand = steer;
            lastDriveCommand = drive;
            
            throttledCommand(Math.round(drive), Math.round(steer));
            document.getElementById('personVal').textContent = Math.round(personSize);
            updateDebug(errorX, filteredSize, drive, steer, person.score * 100, pTerm, iTerm, dTerm);
        }

        function handleTargetLoss() {
            document.getElementById('personVal').textContent = 'NONE';
            updateDebug(0, 0, 0, 0, 0, 0, 0, 0);
            if (!lastDetectionTime) {
                throttledCommand(0, 0);
                return;
            }
            const since = Date.now() - lastDetectionTime;
            if (since < CONFIG.TARGET_LOSS_TIMEOUT) {
                const ramp = clamp(1 - (since / CONFIG.TARGET_LOSS_TIMEOUT), 0, 1);
                const steer = Math.round(lastSteerCommand * ramp);
                const drive = Math.round(lastDriveCommand * ramp);
                commandFilterState.steer = steer;
                commandFilterState.drive = drive;
                throttledCommand(drive, steer);
            } else {
                throttledCommand(0, 0);
                resetControlState();
                filteredOffset *= 0.5;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STEERING ENHANCEMENT FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function applySteeringCurve(steer, error) {
            // Apply non-linear response for better control
            const absError = Math.abs(error);
            const normalizedError = absError / (canvas.width / 2);
            
            // More aggressive response for larger errors
            if (normalizedError > 0.3) {
                return steer * 1.2;
            }
            // Smoother response for small errors
            else if (normalizedError < 0.1) {
                return steer * 0.8;
            }
            
            return steer;
        }
        
        function applySoftZoneGain(value, error) {
            const absError = Math.abs(error);
            if (absError <= CONFIG.DEAD_ZONE) return 0;
            if (CONFIG.SOFT_ZONE <= 0) return value;
            const excess = absError - CONFIG.DEAD_ZONE;
            const scale = clamp(excess / CONFIG.SOFT_ZONE, 0, 1);
            return value * scale;
        }

        function clamp(val, min, max) {
            return Math.min(max, Math.max(min, val));
        }

        function lowPassFilter(target, lastValue, alpha) {
            if (!isFinite(lastValue)) lastValue = 0;
            if (!isFinite(target)) return lastValue;
            const a = clamp(alpha, 0, 1);
            return lastValue + a * (target - lastValue);
        }

        function slewLimit(target, lastValue, maxDelta) {
            if (!isFinite(maxDelta) || maxDelta <= 0) return target;
            const delta = target - lastValue;
            if (Math.abs(delta) <= maxDelta) return target;
            return lastValue + Math.sign(delta) * maxDelta;
        }

        function getNow() {
            return (typeof performance !== 'undefined' ? performance.now() : Date.now());
        }

        function selectTarget(candidates) {
            if (!candidates.length) return null;
            const referenceX = CONFIG.FRAME_CENTER_X + filteredOffset;
            let best = null;
            candidates.forEach(p => {
                const [x, , w, h] = p.bbox;
                const cx = x + w / 2;
                const area = w * h;
                const alignment = 1 - Math.min(1, Math.abs(cx - referenceX) / canvas.width);
                const composite = (p.score * 0.5) + (clamp(area / CONFIG.TARGET_SIZE, 0, 2) * 0.3) + (alignment * 0.2);
                if (!best || composite > best.score) {
                    best = { score: composite, person: p };
                }
            });
            return best ? best.person : null;
        }
        
        function resetControlState() {
            pidState.integral = 0;
            pidState.prevError = 0;
            filteredOffset = 0;
            filteredSize = CONFIG.TARGET_SIZE;
            lastSteerCommand = 0;
            lastDriveCommand = 0;
            commandFilterState = { steer: 0, drive: 0 };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALTERNATE MODES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function patrolMode() {
            const t = Date.now() / 2000;
            const drive = 40;
            const steer = Math.sin(t) * 60;
            throttledCommand(drive, Math.round(steer));
        }

        function scanMode() {
            const t = Date.now() / 1000;
            const steer = Math.sin(t) * 70;
            throttledCommand(0, Math.round(steer));
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMMAND TRANSMISSION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function throttledCommand(drive, steer) {
            const now = Date.now();
            if (now - lastCommandTime < CONFIG.COMMAND_RATE) return;
            lastCommandTime = now;
            
            sendCmd(drive, steer);
        }

        function sendCmd(drive, steer) {
            if (!connected) return;
            
            // Update UI
            document.getElementById('driveVal').textContent = drive;
            document.getElementById('steerVal').textContent = steer;
            
            // Send to ESP32
            fetch(`http://${esp32Ip}/control?drive=${drive}&steer=${steer}`)
                .then(r => {
                    if (!r.ok) throw new Error('HTTP ' + r.status);
                    return r.json();
                })
                .then(data => {
                    cmdCount++;
                    if (cmdCount % 15 === 0) {
                        log(`ğŸ“¡ CMD #${cmdCount}: D=${drive} S=${steer}`);
                    }
                })
                .catch(e => {
                    console.error('Command error:', e);
                    if (cmdCount % 50 === 0) {
                        log('âš ï¸ Command transmission error');
                    }
                });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MODE CONTROL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setMode(m) {
            mode = m;
            
            // Update UI
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('mode' + m.charAt(0).toUpperCase() + m.slice(1)).classList.add('active');
            
            log(`ğŸ® Mode: ${m.toUpperCase()}`);
            
            if (m === 'follow') {
                lastDetectionTime = Date.now();
            }
            
            if (m === 'stop') {
                sendCmd(0, 0);
                lastSteerError = 0;
                resetControlState();
            }
        }

        function emergency() {
            if (!connected) {
                log('âš ï¸ Not connected to ESP32');
                return;
            }
            
            fetch(`http://${esp32Ip}/emergency`)
                .then(() => {
                    log('ğŸš¨ EMERGENCY STOP ACTIVATED');
                    document.getElementById('driveVal').textContent = '0';
                    document.getElementById('steerVal').textContent = '0';
                    mode = 'stop';
                    setMode('stop');
                    lastSteerError = 0;
                    resetControlState();
                })
                .catch(e => log('âŒ Emergency stop failed: ' + e.message));
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI UPDATES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateStatus(type, on, text) {
            document.getElementById(type + 'Status').className = 'status ' + (on ? 'on' : 'off');
            document.getElementById(type + 'Text').textContent = text;
        }

        function updateDebug(offsetX, size, drive, steer, conf, pTerm, iTerm, dTerm) {
            document.getElementById('debugOffsetX').textContent = Math.round(offsetX) + ' px';
            document.getElementById('debugError').textContent = Math.round(offsetX) + ' px';
            document.getElementById('debugSize').textContent = Math.round(size) + ' pxÂ²';
            document.getElementById('debugDrive').textContent = Math.round(drive);
            document.getElementById('debugSteer').textContent = Math.round(steer);
            document.getElementById('debugConf').textContent = Math.round(conf) + '%';
            document.getElementById('debugPterm').textContent = Math.round(pTerm * 100) / 100;
            document.getElementById('debugIterm').textContent = Math.round(iTerm * 100) / 100;
            document.getElementById('debugDterm').textContent = Math.round(dTerm * 100) / 100;
        }

        function log(msg) {
            const el = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML = `<div style="color:#0ff">[${time}]</div> ${msg}<br>` + el.innerHTML;
            
            // Limit log size
            const lines = el.innerHTML.split('<br>');
            if (lines.length > 30) {
                el.innerHTML = lines.slice(0, 30).join('<br>');
            }
        }
    </script>
</body>
</html>
